(ns core-macro-test
  "Comprehensive tests for core macros: when-let, if-let, and, or, ->, ->>, cond, for, doto")

;; ============================================================================
;; when-let tests
;; ============================================================================

(deftest test-when-let-truthy
  ;; when-let should execute body when binding is truthy
  (is (= 10 (when-let [x 5]
              (+ x 5)))))

(deftest test-when-let-falsy
  ;; when-let should return nil when binding is falsy
  (is (nil? (when-let [x nil]
              (+ x 5)))))

(deftest test-when-let-false
  ;; when-let should return nil when binding is false
  (is (nil? (when-let [x false]
              :executed))))

(deftest test-when-let-zero
  ;; when-let should execute when binding is 0 (truthy in Clojure)
  (is (= 0 (when-let [x 0]
             x))))

;; ============================================================================
;; if-let tests
;; ============================================================================

(deftest test-if-let-truthy
  ;; if-let should execute then branch when binding is truthy
  (is (= 10 (if-let [x 5]
              (+ x 5)
              :else))))

(deftest test-if-let-falsy
  ;; if-let should execute else branch when binding is nil
  (is (= :else (if-let [x nil]
                 (+ x 5)
                 :else))))

(deftest test-if-let-false-value
  ;; if-let should execute else branch when binding is false
  (is (= :was-false (if-let [x false]
                      :was-true
                      :was-false))))

;; ============================================================================
;; and tests
;; ============================================================================

(deftest test-and-all-true
  ;; and should return last value when all are truthy
  (is (= 3 (and 1 2 3))))

(deftest test-and-with-false
  ;; and should return false when encountering false
  (is (false? (and 1 false 3))))

(deftest test-and-with-nil
  ;; and should return nil when encountering nil
  (is (nil? (and 1 nil 3))))

(deftest test-and-empty
  ;; (and) with no args should return true
  (is (true? (and))))

(deftest test-and-single
  ;; (and x) should return x
  (is (= 5 (and 5))))

(deftest test-and-short-circuit
  ;; and should short-circuit (not evaluate remaining forms)
  (let [counter (atom 0)]
    (and false (reset! counter 99))
    (is (= 0 @counter))))

;; ============================================================================
;; or tests
;; ============================================================================

(deftest test-or-first-truthy
  ;; or should return first truthy value
  (is (= 1 (or 1 2 3))))

(deftest test-or-skip-nil
  ;; or should skip nil and return next truthy value
  (is (= 2 (or nil 2 3))))

(deftest test-or-skip-false
  ;; or should skip false and return next truthy value
  (is (= 3 (or false nil 3))))

(deftest test-or-all-falsy
  ;; or should return last value when all are falsy
  (is (nil? (or false nil))))

(deftest test-or-empty
  ;; (or) with no args should return nil
  (is (nil? (or))))

(deftest test-or-single
  ;; (or x) should return x
  (is (= 5 (or 5))))

(deftest test-or-short-circuit
  ;; or should short-circuit when finding truthy value
  (let [counter (atom 0)]
    (or 1 (reset! counter 99))
    (is (= 0 @counter))))

;; ============================================================================
;; -> (thread-first) tests
;; ============================================================================

(deftest test-thread-first-simple
  ;; -> should thread value as first argument
  (is (= 6 (-> 5 inc))))

(deftest test-thread-first-multiple
  ;; -> should chain multiple operations
  (is (= 7 (-> 5 inc inc))))

(deftest test-thread-first-with-args
  ;; -> should work with forms that have additional args
  (is (= 2 (-> 10 (- 8)))))  ; (- 10 8) = 2

(deftest test-thread-first-nested
  ;; -> should work with multiple forms with args
  (is (= 1 (-> 10 (- 8) (- 1)))))  ; (- (- 10 8) 1) = (- 2 1) = 1

(deftest test-thread-first-with-vector
  ;; -> should thread through collection operations
  ;; [1 2 3] -> conj 4 -> [1 2 3 4] -> count -> 4 -> inc -> 5
  (is (= 5 (-> [1 2 3]
               (conj 4)
               count
               inc))))

;; ============================================================================
;; ->> (thread-last) tests
;; ============================================================================

(deftest test-thread-last-simple
  ;; ->> should thread value as last argument
  (is (= 3 (->> [1 2 3] count))))

(deftest test-thread-last-with-map
  ;; ->> should work with map
  (is (= [2 3 4] (vec (->> [1 2 3] (map inc))))))

(deftest test-thread-last-multiple
  ;; ->> should chain multiple operations
  (is (= [2 4] (vec (->> [1 2 3 4]
                         (filter even?))))))

(deftest test-thread-last-with-reduce
  ;; ->> with reduce
  (is (= 10 (->> [1 2 3 4]
                 (reduce +)))))

;; ============================================================================
;; cond tests
;; ============================================================================

(deftest test-cond-first-match
  ;; cond should return first matching clause
  (is (= :one (cond
                (= 1 1) :one
                (= 2 2) :two
                :else :default))))

(deftest test-cond-second-match
  ;; cond should skip false clauses
  (is (= :two (cond
                (= 1 2) :one
                (= 2 2) :two
                :else :default))))

(deftest test-cond-else
  ;; cond should fall through to :else
  (is (= :default (cond
                    (= 1 2) :one
                    (= 2 3) :two
                    :else :default))))

(deftest test-cond-no-match
  ;; cond with no match returns nil
  (is (nil? (cond
              (= 1 2) :one
              (= 2 3) :two))))

;; ============================================================================
;; for (eager list comprehension) tests
;; ============================================================================

(deftest test-for-basic
  ;; for should produce a collection
  (is (= [2 4 6] (vec (for [x [1 2 3]] (* x 2))))))

(deftest test-for-with-strings
  ;; for should work with any collection
  (is (= ["a!" "b!" "c!"] (vec (for [s ["a" "b" "c"]] (str s "!"))))))

(deftest test-for-empty
  ;; for on empty collection should return empty
  (is (= [] (vec (for [x []] x)))))

;; ============================================================================
;; if-not tests
;; ============================================================================

(deftest test-if-not-false
  ;; if-not should execute then when test is false
  (is (= :then (if-not false :then :else))))

(deftest test-if-not-nil
  ;; if-not should execute then when test is nil
  (is (= :then (if-not nil :then :else))))

(deftest test-if-not-true
  ;; if-not should execute else when test is true
  (is (= :else (if-not true :then :else))))

;; ============================================================================
;; when-not tests
;; ============================================================================

(deftest test-when-not-false
  ;; when-not should execute body when test is false
  (is (= :result (when-not false :result))))

(deftest test-when-not-true
  ;; when-not should return nil when test is true
  (is (nil? (when-not true :result))))

;; TODO: test-when-not-multiple-body temporarily removed - triggers emitter bug
;; with nil/null in statement context inside if blocks
