(ns hof-test
  "Higher-order function tests - testing function passing")

;; ============================================================================
;; map with lambda - Should work (lambdas are emitted correctly)
;; ============================================================================

(deftest test-map-with-lambda
  (is (= [2 3 4] (vec (map (fn [x] (+ x 1)) [1 2 3]))))
  (is (= [2 4 6] (vec (map (fn [x] (* x 2)) [1 2 3])))))

;; ============================================================================
;; filter with lambda - Should work
;; ============================================================================

(deftest test-filter-with-lambda
  (is (= [2 4] (vec (filter (fn [x] (even? x)) [1 2 3 4]))))
  (is (= [1 3] (vec (filter (fn [x] (odd? x)) [1 2 3 4])))))

;; ============================================================================
;; reduce with lambda - Should work
;; ============================================================================

(deftest test-reduce-with-lambda
  (is (= 10 (reduce (fn [acc x] (+ acc x)) 0 [1 2 3 4])))
  (is (= 24 (reduce (fn [acc x] (* acc x)) 1 [1 2 3 4]))))

;; ============================================================================
;; map with core function - Testing HOC with core functions
;; ============================================================================

(deftest test-map-with-inc
  ;; This is the key test - does (map inc [1 2 3]) work?
  (is (= [2 3 4] (vec (map inc [1 2 3])))))

(deftest test-map-with-dec
  (is (= [0 1 2] (vec (map dec [1 2 3])))))

(deftest test-map-with-str
  (is (= ["1" "2" "3"] (vec (map str [1 2 3])))))

;; ============================================================================
;; filter with core predicates
;; ============================================================================

(deftest test-filter-with-even?
  (is (= [2 4 6] (vec (filter even? [1 2 3 4 5 6])))))

(deftest test-filter-with-odd?
  (is (= [1 3 5] (vec (filter odd? [1 2 3 4 5 6])))))

(deftest test-filter-with-nil?
  (is (= [nil nil] (vec (filter nil? [1 nil 2 nil 3])))))

(deftest test-filter-with-some?
  (is (= [1 2 3] (vec (filter some? [1 nil 2 nil 3])))))

;; ============================================================================
;; every? and some with predicates
;; ============================================================================

(deftest test-every?-with-even?
  (is (every? even? [2 4 6]))
  (is (not (every? even? [1 2 3]))))

(deftest test-some-with-even?
  (is (true? (some even? [1 2 3])))
  (is (nil? (some even? [1 3 5]))))

;; ============================================================================
;; Nested HOCs
;; ============================================================================

(deftest test-nested-map-filter
  (is (= [4 8] (vec (map (fn [x] (* x 2)) (filter even? [1 2 3 4]))))))

(deftest test-thread-with-hof
  (is (= [4 8] (->> [1 2 3 4]
                    (filter even?)
                    (map (fn [x] (* x 2)))
                    vec))))

;; ============================================================================
;; reduce-kv test
;; ============================================================================

(deftest test-reduce-kv
  (is (= 6 (reduce-kv (fn [acc k v] (+ acc v)) 0 {:a 1 :b 2 :c 3}))))

;; ============================================================================
;; remove with predicate
;; ============================================================================

(deftest test-remove-with-even?
  (is (= [1 3 5] (vec (remove even? [1 2 3 4 5])))))

;; ============================================================================
;; keep with function
;; ============================================================================

(deftest test-keep-with-lambda
  ;; keep returns non-nil results of (fn x) - even numbers doubled
  (is (= [4 8 12] (vec (keep (fn [x] (if (even? x) (* x 2) nil)) [1 2 3 4 5 6])))))

;; ============================================================================
;; take-while and drop-while
;; ============================================================================

(deftest test-take-while-with-predicate
  ;; take-while takes all even elements until first odd (1)
  (is (= [2 4 6] (vec (take-while even? [2 4 6 1 3])))))

(deftest test-drop-while-with-predicate
  (is (= [1 3] (vec (drop-while even? [2 4 1 3])))))

;; ============================================================================
;; sort-by with key function
;; ============================================================================

(deftest test-sort-by-with-lambda
  ;; Use (get m :a) instead of (:a m) since keywords as functions need emitter support
  (is (= [{:a 1} {:a 2} {:a 3}]
         (vec (sort-by (fn [m] (get m :a)) [{:a 3} {:a 1} {:a 2}])))))

;; ============================================================================
;; group-by with function
;; ============================================================================

(deftest test-group-by-with-even?
  (let [result (group-by even? [1 2 3 4 5 6])]
    (is (= [2 4 6] (get result true)))
    (is (= [1 3 5] (get result false)))))

;; ============================================================================
;; partition-by with function
;; ============================================================================

(deftest test-partition-by-with-even?
  (is (= [[1] [2] [3] [4] [5]]
         (vec (map vec (partition-by even? [1 2 3 4 5]))))))

;; ============================================================================
;; mapcat with function
;; ============================================================================

(deftest test-mapcat-with-lambda
  (is (= [1 1 2 2 3 3] (vec (mapcat (fn [x] [x x]) [1 2 3])))))

;; ============================================================================
;; iterate test
;; ============================================================================

(deftest test-iterate-with-inc
  (is (= [0 1 2 3 4] (vec (take 5 (iterate inc 0))))))

;; ============================================================================
;; repeatedly test
;; ============================================================================

(deftest test-repeatedly-with-lambda
  (is (= [42 42 42] (vec (repeatedly 3 (fn [] 42))))))

;; ============================================================================
;; distinct test
;; ============================================================================

(deftest test-distinct
  (is (= [1 2 3] (vec (distinct [1 1 2 2 3 3])))))

;; ============================================================================
;; dedupe test
;; ============================================================================

(deftest test-dedupe
  (is (= [1 2 3 2 1] (vec (dedupe [1 1 2 2 3 3 2 2 1 1])))))

;; ============================================================================
;; interleave and interpose
;; ============================================================================

(deftest test-interleave
  (is (= [1 :a 2 :b] (vec (interleave [1 2 3] [:a :b])))))

(deftest test-interpose
  (is (= [1 :x 2 :x 3] (vec (interpose :x [1 2 3])))))

;; ============================================================================
;; cycle test
;; ============================================================================

(deftest test-cycle
  (is (= [1 2 3 1 2 3 1] (vec (take 7 (cycle [1 2 3]))))))

;; ============================================================================
;; comp and partial (function combinators)
;; ============================================================================

(deftest test-comp-simple
  ;; comp creates a composed function
  (let [inc-twice (comp inc inc)]
    (is (= 3 (inc-twice 1)))))

(deftest test-partial-simple
  ;; partial creates a partially applied function
  ;; Use (fn [a b] (+ a b)) instead of + since + is variadic and emitter wraps as 1-arg
  (let [add5 (partial (fn [a b] (+ a b)) 5)]
    (is (= 8 (add5 3)))))

;; ============================================================================
;; juxt test
;; ============================================================================

(deftest test-juxt
  (let [stats (juxt count first last)]
    (is (= [3 1 3] (vec (stats [1 2 3]))))))

;; ============================================================================
;; complement test
;; ============================================================================

(deftest test-complement
  (let [not-even? (complement even?)]
    (is (true? (not-even? 1)))
    (is (false? (not-even? 2)))))
